---
layout: post
title: Experimenting with the CSR1000v REST API
date: '2015-02-12T11:18:00.000-07:00'
author: Jay Swan
tags: 
modified_time: '2015-02-12T14:24:53.822-07:00'
blogger_id: tag:blogger.com,1999:blog-5029689981158113588.post-2869633211592041286
blogger_orig_url: http://unroutable.blogspot.com/2015/02/experimenting-with-csr1000v-rest-api.html
---

This all started because we occasionally want to block traffic from an IP address or two for a short time. Our firewall is a pain to configure for this sort of thing: adding a drop for a single IP address literally takes 10 minutes. You have to open a fat client, create an object, add the object to a group, save the config, verify the config, push the config, etc.<br /><br />I thought that SRTBH (Source-based <a href="http://www.cisco.com/web/about/security/intelligence/blackhole.pdf" target="_blank">Real-Time Black Hole</a>) implemented by BGP would be the ticket: fast, easy, and theoretically easy to automate with the <a href="http://www.cisco.com/c/en/us/td/docs/routers/csr1000/software/restapi/restapi/RESTAPIintro.html" target="_blank">REST API in the Cisco Cloud Services Router 1000v</a>. SRTBH is a simple and elegant way of dropping selected traffic on BGP speaking routers. In a nutshell: <br /><ol><li>You configure a "trigger router" that speaks iBGP with the rest of your BGP-speaking routers (usually your Internet edge or transit routers), but doesn't participate in traffic forwarding.</li><li>On each edge/transit router you configure a static route to null0 for an unused /32, usually 192.0.2.1: <span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ip route 192.0.2.1 255.255.255.255 null0</span></span></li><li>On each edge/transit router you configure loose-mode unicast RPF filtering on your outside interfaces: <span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ip verify source reachable-via any</span></span>. This has a special property: packets from any source for which the uRPF next-hop resolves to Null0 will be dropped.</li><li>When you want to drop traffic from a particular host (e.g. 1.1.1.2), you configure a static host route on the trigger router and redistribute it into BGP by matching its tag: <span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ip route 1.1.1.2 255.255.255.255 null0 tag 666</span></span>. </li><li>At redistribution, you set its next-hop to 192.0.2.1:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">route-map SRTBH permit 10<br />&nbsp;description BGP Black Hole <br />&nbsp;match tag 666<br />&nbsp;set origin igp<br />&nbsp;set community no-export<br />&nbsp;set ip next-hop 192.0.2.1</span></span></li></ol>The effect of this is that the edge routers see the iBGP route to the "bad" address as a /32 with a next-hop of 192.0.2.1. Because the next-hop for 192.0.2.1 recursively resolves to null0, the loose uRPF feature drops traffic from the bad host at the edge.<br /><br />In my case, I wanted to use the CSR1000v as the trigger router. (At this point, somebody's thinking "Why not use a Linux BGP daemon?") That's a valid approach; I just want to use the CSR1000v. <br /><br />I followed the <a href="http://www.cisco.com/c/en/us/td/docs/routers/csr1000/software/configuration/csr1000Vswcfg/RESTAPI.html" target="_blank">REST setup instructions</a>, then wrote a <a href="https://github.com/jayswan/csr_rest" target="_blank">simple CLI tool</a> to make testing easier. It's easy enough to test the API with cURL:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$ curl -X POST https://10.1.1.1:55443/api/v1/auth/token-services -H "Accept:application/json" -u "testuser" -d "" --insecure -3<br />Enter host password for user 'testuser':<br />{"kind": "object#auth-token", "expiry-time": "Thu Feb 12 17:24:30 2015", "token-id": "xNOvrJh[...]rW3x0=", "link": "https://10.1.1.1:55443/api/v1/auth/token-services/2285580579"}</span></span><br /><br />but because the API requires that you obtain a temporary authorization token (demonstrated above) before doing anything interesting, writing the Python tool made sense.<br /><br />Then the problems started: the REST API on the CSR1000v doesn't support tags on static routes. You can't add them, or even retrieve them. Here's what happens normally if you retrieve static routes:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;python rest.py --device 10.1.1.1 --user testuser --resource /routing-svc/static-routes<br />Password:<br />{u'items': [{u'admin-distance': 1,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u'destination-network': u'10.0.0.0/8',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u'kind': u'object#static-route',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u'next-hop-router': u'10.30.254.152',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u'outgoing-interface': u''},<br />&nbsp;u'kind': u'collection#static-route'}</span></span><br /><br />If one of the routes has a tag, it throws an error:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">{u'detail': u' ',<br />&nbsp;u'error-code': -1,<br />&nbsp;u'error-message': u"invalid literal for int() with base 10: 'tag'"}</span></span><br /><br />You can't set tags either. Furthermore, the same thing holds true for static routes with the "name" argument. (Incidentally, the error message seems to indicate that the IOS XE API is written in Python.)<br /><br />The problem with this is that without tags, there's no convenient way to filter the RTBH black hole trigger routes at the time of redistribution. You can't set route-maps on BGP network statements via the API either, so no joy there.<br /><br />The best option to me seems to be to redistribute all static routes, but filter on prefix-length rather than tag:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">route-map SRTBH permit 10<br />&nbsp;description BGP Black Hole<br />&nbsp;match ip address prefix-list HOST_ROUTES_ONLY<br />&nbsp;set origin igp<br />&nbsp;set community no-export<br />&nbsp;set ip next-hop 192.0.2.1</span></span><br /><br />But then you have to make sure that you never have any /32s that aren't trigger routes... a strategy which is prone to configuration mistakes.<br /><br />Because SRTBH seems like a natural use-case for API automation, I hope Cisco fixes this soon.<br /><br />[added]<br />Other interesting things I've found: the static route configuration API doesn't allow you to add equal-cost static routes. For example, if I already have a 1.1.1.5/32 route and I add another one, I get a 404:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">python rest.py --device 10.1.1.1 --user testuser --password foo --resource /routing-svc/static-routes --method post --json '{"destination-network":"1.1.1.5/32","outgoing-interface":"null0"}' --verbose<br />[snip]<br /><span style="background-color: yellow;">DEBUG:root:got status code: 404</span><br /><span style="background-color: yellow;">DEBUG:root:reponse content: Static route already exists</span><br />got status code: 404 </span></span><br /><br />The same thing goes for adding other items: I tried adding a name-server twice, and got a similar error. I would think that the API would be idempotent where possible (such as when adding a duplicate nameserver), and require clarifying attributes otherwise. With equal-cost static routes for example, it could throw a 40x unless an extra attribute like <span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">{"allow-equal-cost":true} </span></span>is present in the POST request.