---
layout: post
title: How to Tell if TCP Payloads Are Identical
date: '2013-11-01T19:41:00.000-06:00'
author: Jay Swan
tags: 
modified_time: '2013-11-01T19:41:53.769-06:00'
blogger_id: tag:blogger.com,1999:blog-5029689981158113588.post-3650520714688013553
blogger_orig_url: http://unroutable.blogspot.com/2013/11/how-to-tell-if-tcp-payloads-are.html
---

<span style="font-family: inherit;">I was working on a problem today in which vendor tech support was suggesting that a firewall was subtly modifying TCP data payloads. I couldn't find any suggestion of this in the firewall logs, but seeing as how I've seen that vendor's firewall logs lie egregiously in the past, I wanted to verify it independently.</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">I took a packet capture from both hosts involved in the conversation and started thinking about how to see if the data sent by the server was the same as the data received by the client. I couldn't just compare the capture files themselves, because elements like timestamps, TTLs, and IP checksums would be different.</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">After a bunch of fiddling around, I came up with the idea of using tshark to extract the TCP payloads for each stream in the capture file and hash the results. If the hashes matched, the TCP payloads were being transferred unmodified. Here are the shell commands to do this:</span><br /><br /><span style="font-family: Courier New, Courier, monospace;">tshark -r server.pcap -T fields -e tcp.stream | sort -u | sed 's/\r//' |&nbsp;xargs -i tshark -r server.pcap -q -z follow,tcp,raw,{} | md5sum</span><br /><span style="font-family: Courier New, Courier, monospace;">2cfe2dbb5f6220f29ff8aff82f7f68f5 *-</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: inherit;">You then run exactly the same commands on the "client.pcap" file and compare the resulting hashes. Let's break this down a bit more:</span><br /><span style="font-family: inherit; font-size: x-small;"><br /></span><span style="font-family: 'Courier New', Courier, monospace;">tshark -r server.pcap -T fields -e tcp.stream</span><br /><br />This invokes tshark to read the "server.pcap" file and output the TCP stream indexes of each packet. This is just a long series of integers:<br /><span style="font-size: x-small;"><br /></span>0<br />0<br />1<br />2<br />1<br />etc.<br /><span style="font-size: x-small;"><br /></span>The next command, <span style="font-family: Courier New, Courier, monospace;">sort -u</span>, produces a logical set of the unique (hence the "-u") stream indexes. In other words, it removes duplicates from the previous list. Not all Unix-like operating systems have the "<span style="font-family: Courier New, Courier, monospace;">sort -u</span>" option; if yours is missing it, you can use "<span style="font-family: Courier New, Courier, monospace;">| sort | uniq</span>" instead.<br /><br />Next,<span style="font-family: Courier New, Courier, monospace;"> sed 's/\r//'</span> removes the line break from the end of the resulting stream indexes. If you don't do this, you'll get an error from the next command.<br /><span style="font-size: x-small;"><br /></span>The next one's a bit of a doozy: <span style="font-family: Courier New, Courier, monospace;">xargs -i</span>&nbsp;takes each stream index (remember, these are just integers) and executes the&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">tshark -r server.pcap -q -z follow,tcp,raw,{}</span>command once for each stream index, substituting the input stream index for the {} characters.<br /><br />The&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">tshark -r server.pcap -q -z follow,tcp,raw,{} </span><span style="font-family: inherit;">command itself reads the capture file a second time, running the familiar "Follow TCP Stream in Raw Format" command from Wireshark on the specified TCP stream index that replaces the {} characters. If you're rusty on Wireshark, "Follow TCP Stream" just dumps the TCP payload data in one of a variety of formats, such as "raw" or ASCII. If you've never used this option in Wireshark, make sure you try it today!</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">The final command, </span><span style="font-family: Courier New, Courier, monospace;">md5sum</span><span style="font-family: inherit;">, runs a MD5 hash on the preceding input.</span><br /><span style="font-family: inherit;"><br /></span>To summarize, we've done this: taken a file, extracted all the raw TCP data payloads from its packets (without headers), and hashed the data with MD5. If we do this on two files and the hashes are the same, we know they contain exactly the same TCP data (barring the infinitesimally small probability of a MD5 hash collision).<br /><br />In my case, both capture files produced the same hash, proving that the firewall was (for once) playing nice.