---
layout: post
title: Simple Python Syslog Counter
date: '2014-07-01T19:24:00.001-06:00'
author: Jay Swan
tags: 
modified_time: '2014-07-02T09:06:21.573-06:00'
blogger_id: tag:blogger.com,1999:blog-5029689981158113588.post-6446523674103272606
blogger_orig_url: http://unroutable.blogspot.com/2014/07/simple-python-syslog-counter.html
---

Recently I did a <a href="http://packetpushers.net/show-192-logging-design-best-practices/" target="_blank">Packet Pushers episode about log management</a>. In it, I mentioned some of the custom Python scripts that I run to do basic syslog analysis, and someone asked about them in the comments.<br /><br />The script I'm presenting here isn't one of the actual ones that I run in production, but it's close. The real one sends emails, does DNS lookups, keeps a "rare messages" database using sqlite3, and a few other things, but I wanted to keep this simple.<br /><br />One of the problems I see with getting started with log analysis is that people tend to approach it like a typical vendor RFP project: list some requirements, survey the market, evaluate and buy a product to fit your requirements. Sounds good, right? The problem with log analysis is that often you don't know what your requirements really are until you start looking at data.<br /><br />A simple message counting script like this lets you look at your data, and provides a simple platform on which you can start to iterate to find your specific needs. It also lets us look at some cool Python features.<br /><br />I don't recommend pushing this too far: once you have a decent idea of what your data looks like and what you want to do with it, set up <a href="http://logstash.net/" target="_blank">Logstash</a>, <a href="http://graylog2.com/" target="_blank">Graylog2</a>, or a similar commercial product like Splunk (if you can afford it).<br /><br />That said, <a href="https://gist.github.com/jayswan/96df3f0b9606f2ce84f2" target="_blank">here's the Python</a>:<br /><br /><br /><script src="https://gist.github.com/jayswan/96df3f0b9606f2ce84f2.js"></script> I tried to make this as self-documenting as possible. You run it from the CLI with a syslog file as the argument, and you get this:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$ python simple_syslog_count.py sample.txt<br />&nbsp;214&nbsp;&nbsp; SEC-6-IPACCESSLOGP<br />&nbsp;15&nbsp;&nbsp;&nbsp; SEC-6-IPACCESSLOGRL<br />&nbsp;10&nbsp;&nbsp;&nbsp; LINEPROTO-5-UPDOWN<br />&nbsp;10&nbsp;&nbsp;&nbsp; LINK-3-UPDOWN<br />&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp; USER-3-SYSTEM_MSG<br />&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; STACKMGR-4-STACK_LINK_CHANGE<br />&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; DUAL-5-NBRCHANGE<br />&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; IPPHONE-6-UNREGISTER_NORMAL<br />&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; CRYPTO-4-PKT_REPLAY_ERR<br />&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; SEC-6-IPACCESSLOGRP<br />&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; SEC-6-IPACCESSLOGSP<br />&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; SSH-5-SSH2_USERAUTH<br />&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; SSH-5-SSH2_SESSION<br />&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; SSH-5-SSH2_CLOSE<br /><br />10.1.16.12<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; SEC-6-IPACCESSLOGP<br /><br />10.1.24.3<br /><br />&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; LINEPROTO-5-UPDOWN<br />&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; LINK-3-UPDOWN</span><br /><br />[Stuff deleted for brevity]<br /><br />For Pythonistas, the script makes use of a few cool language features:<br /><ul></ul><h3>Named, Compiled rRgexes</h3><ul><li>We can name a regex match with the<span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> </span><span class="s"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">(?P<yourname>PATTERN)</yourname></span> syntax, which makes it easy to understand it when it's referenced later with the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">.group('<yourname>') </yourname></span>method on the match object.</span></li><li><span class="s">This is demonstrated in lines 36-39 and 58-59 of the gist shown above.&nbsp;</span></li><li><span class="s">It would be more efficient to capture these fields by splitting the line with the .split() string method, but I wanted the script to work for unknown field positions -- hence the regex.&nbsp;</span> </li></ul><h3>Multiplication of Strings</h3><ul><li>We control indentation by multiplying the ' ' string (that a single space enclosed in quotes) by an integer value in the print_counter function (line 50).</li><ul><li>The reason this works is that the Python <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">str</span> class defines a special <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">__mul__ </span>method that controls how the * operator works for objects of that class:<br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; 'foo'.__mul__(3)<br />'foofoofoo'<br />&gt;&gt;&gt; 'foo' * 3<br />'foofoofoo'</span></li></ul></ul><h3>collections.Counter Objects</h3><ul><li>Counter objects are a subclass of dictionaries that know how to count things. Jeremy Schulman talked about these in a comment on the <a href="http://unroutable.blogspot.com/2014/06/python-sets-handy-for-network-data.html" target="_blank">previous post</a>. Here, we use Counters to build both the overall message counts and the per-device message counts:</li></ul><blockquote class="tr_bq"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; my_msg = 'timestamp ip_address stuff %MY-4-MESSAGE:other stuff'<br />&gt;&gt;&gt; CISCO_MSG = re.compile('%(?P<msg>.*?):')<br />&gt;&gt;&gt; from collections import Counter<br />&gt;&gt;&gt; test_counter = Counter()<br />&gt;&gt;&gt; this_msg = re.search(CISCO_MSG,my_msg).group('msg')<br />&gt;&gt;&gt; this_msg<br />'MY-4-MESSAGE'<br />&gt;&gt;&gt; test_counter[this_msg] += 1<br />&gt;&gt;&gt; test_counter<br />Counter({'MY-4-MESSAGE': 1}) </msg></span></blockquote><ul></ul><h3>collections.defaultdict Dictionaries</h3><ul><li>It could get annoying when you're assigning dictionary values inside a loop, because you get errors when the key doesn't exist yet. This is a contrived example, but it illustrates the point:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; reporters = {}<br />&gt;&gt;&gt; for reporter in ['1.1.1.1','2.2.2.2']:<br />...&nbsp;&nbsp;&nbsp;&nbsp; reporters[reporter].append['foo']<br />... <br />Traceback (most recent call last):<br />&nbsp; File "<stdin>", line 2, in <module><br />KeyError: '1.1.1.1'</module></stdin></span><br />&nbsp;</li><li>To fix this, you can catch the exception:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; reporters = {}<br />&gt;&gt;&gt; for reporter in ['1.1.1.1','2.2.2.2']:<br />...&nbsp;&nbsp;&nbsp;&nbsp; try:<br />...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reporters[reporter].append['foo']<br />...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reporters[reporter].append['bar']<br />...&nbsp;&nbsp;&nbsp;&nbsp; except KeyError:<br />...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reporters[reporter] = ['foo']<br />...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reporters[reporter].append('bar')</span></li></ul><ul><li>As usual, though, Python has a more elegant way in the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">collections</span> module: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">defaultdict</span> </li></ul><blockquote class="tr_bq"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; from collections import defaultdict<br />&gt;&gt;&gt; reporters = defaultdict(list)<br />&gt;&gt;&gt; for reporter in ['1.1.1.1','2.2.2.2']:<br />...&nbsp;&nbsp;&nbsp;&nbsp; reporters[reporter].append('foo')<br />...&nbsp;&nbsp;&nbsp;&nbsp; reporters[reporter].append('bar')<br />&gt;&gt;&gt; reporters<br />defaultdict(<type list="">, {'1.1.1.1': ['foo', 'bar'], '2.2.2.2': ['foo', 'bar']})</type></span></blockquote>In the syslog counter script, we use a <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">collections.Counter</span> object as the type for our defaultdict. This allows us to build a per-syslog-reporter dictionary that shows how many times each message appears for each reporter, while only looping through the input once (line 66):<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;per_reporter_counts[reporter][msg] += 1</span><br /><br />Here, the dictionary <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">per_reporter_counts</span> has the IPv4 addresses of the syslog reporters as keys, with a <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Counter</span> object as the value holding the counts for each message type:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; from collections import Counter,defaultdict<br />&gt;&gt;&gt; per_reporter_counts = defaultdict(Counter)<br />&gt;&gt;&gt; per_reporter_counts['1.1.1.1']['SOME-5-MESSAGE'] += 1<br />&gt;&gt;&gt; per_reporter_counts<br />defaultdict(<class collections.counter="">, {'1.1.1.1': Counter({'SOME-5-MESSAGE': 1})})<br />&gt;&gt;&gt; per_reporter_counts['1.1.1.1']['SOME-5-MESSAGE'] += 5<br />&gt;&gt;&gt; per_reporter_counts<br />defaultdict(<class collections.counter="">, {'1.1.1.1': Counter({'SOME-5-MESSAGE': 6})})</class></class></span><br /><br />If you got this far, you can go implement it for IPv6 addresses. :-)