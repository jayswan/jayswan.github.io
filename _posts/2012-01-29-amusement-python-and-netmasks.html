---
layout: post
title: 'Amusement: Python and Netmasks'
date: '2012-01-29T14:20:00.001-07:00'
author: Jay Swan
tags: 
modified_time: '2012-01-29T14:24:51.705-07:00'
blogger_id: tag:blogger.com,1999:blog-5029689981158113588.post-2940600999529580331
blogger_orig_url: http://unroutable.blogspot.com/2012/01/amusement-python-and-netmasks.html
---

As a network engineer, it's not uncommon for me to need to convert between hex and decimal. While I'm reasonably good at doing this in my head for smaller numbers, when it comes to deciphering stuff like higher TCP or UDP port numbers written in hex, I usually end up using the Python interpreter that's usually open somewhere on my machine. For me, the Python interpreter is the best general purpose calculator app I've found. Using the port number for Flash as an example:<br /><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">jswan$ python</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">Python 2.7.2 (v2.7.2:8527427914a2, Jun 11 2011, 15:22:34) </div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">Type "help", "copyright", "credits" or "license" for more information.</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; 0x78f</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">1935</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; hex(1935)</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">'0x78f'</div><br />The topic of numeric base conversions often makes my mind drift to every former networking instructor's pet topics, IPv4 subnetting. The other day, I started playing with using the Python interpreter to find network IDs, which is really easy as long as you're using hex:<br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&gt;&gt;&gt; hex(0x0a0a0a25 &amp; 0xffffffe0)</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">'0xa0a0a20'</div><br />This little snippet finds the bitwise-AND of 10.10.10.37 and 255.255.255.224, which as every up-and-coming CCNA knows is the network ID for that subnet: 10.10.10.32. Back when I was teaching Cisco classes full-time, I used to have a never-ending argument with another instructor about the fact that I didn't teach bitwise operations as part of subnetting: my position was that if all you are doing is solving subnet problems with your squishy human brain, you don't need to learn a bunch of truth tables when there are easier ways to do it in human memory. However, if you're writing code you actually do need to do bitwise operations.<br /><br />Unfortunately most of us (me included) aren't wired for reading IPv4 addresses in hex. So I started wondering how little Python code I could use to calculate network IDs for IPv4 in dotted decimal. A little screwing around and I started wondering if I could fit the entire thing into a Twitter post. Here's what I came up with:<br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">while 1:'.'.join([str(a&amp;m)for a,m in zip([int(n)for n in raw_input('addr?').split('.')],[int(n)for n in raw_input('mask?').split('.')])])</div><br />&nbsp;Try it:<br /><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">addr?1.1.1.37</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">mask?255.255.255.224</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">'1.1.1.32'</div><br />Now I realize this bit of code is neither particularly clever nor easy to read, which makes it bad code. But hey, it fits in a single tweet. It works by using one of Python's coolest features, the list comprehension. If we start with the innermost parts, it makes more sense:<br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[int(n) for n in raw_input('addr?').split('.')]</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[int(n) for n in raw_input('addr?').split('.')]</div><br />These two sections return lists of integers corresponding to the address and mask the user enters. For example:<br /><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[1,1,1,37]</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[255,255,255,224]</div><br />Next, the "zip" function returns a list of tuples that pair corresponding entries in the two lists:<br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[(1, 255), (1, 255), (1, 255), (37, 224)]</div><br />Next, the outermost list comprehension performs a bitwise-AND of each tuple, returning the octets of our network ID in a new list:<br /><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">[1,1,1,32]</div><br />Finally, the "join" method puts them back together into "1.1.1.32", and "while 1:" makes it a loop until you ctrl-c out of it.<br /><br />Working with netmasks in CIDR notation is a bit more complicated, and requires more than one line of code--I'll save that for another post.